<link rel="stylesheet" href="github-markdown.css"><style> .markdown-body {   min-width: 200px;    max-width: 1080;     margin: 0 auto;   padding: 60px;  }</style> <article class="markdown-body"><h1 id="type-overview">Type overview</h1>
<table>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Declared in</th>
<th align="left">Kind</th>
<th align="left">Docstring</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>Any</strong></td>
<td align="left">Any</td>
<td align="left"><code>*</code></td>
<td align="left">The supertype of every single type. Each type has <code>Any</code> implicitly as supertype.</td>
</tr>
<tr class="even">
<td align="left"><strong>BIInt</strong></td>
<td align="left">Builtins</td>
<td align="left"><code>*</code></td>
<td align="left">A int! This is a temporary representation, which will be replaced by a truly builtin one</td>
</tr>
<tr class="odd">
<td align="left"><strong>Eq</strong></td>
<td align="left">Category.Eq</td>
<td align="left"><code>*</code></td>
<td align="left">The category which defines <em>equality</em> <code>==</code> and <em>inequality</em> <code>!=</code></td>
</tr>
<tr class="even">
<td align="left"><strong>Associative</strong> <code>a</code></td>
<td align="left">Category.Function</td>
<td align="left"><code>(* ~&gt; *)</code></td>
<td align="left">Functions for which the order of evaluation does not matter.</td>
</tr>
<tr class="odd">
<td align="left"><strong>Commutative</strong> <code>a</code> <code>b</code></td>
<td align="left">Category.Function</td>
<td align="left"><code>(* ~&gt; (* ~&gt; *))</code></td>
<td align="left">Functions for which the arguments can be swapped.</td>
</tr>
<tr class="even">
<td align="left"><strong>Mappable</strong> <code>a</code></td>
<td align="left">Category.Mappable</td>
<td align="left"><code>(* ~&gt; *)</code></td>
<td align="left">A <em>container</em> on which <code>map</code> is defined. Also known as <code>Functor</code> in most other functional programming languages.</td>
</tr>
<tr class="odd">
<td align="left"><strong>Monoid</strong></td>
<td align="left">Category.Monoid</td>
<td align="left"><code>*</code></td>
<td align="left">A <code>Monoid</code> is an type which has <em>neutral element</em> and an <em>addition</em>.</td>
</tr>
<tr class="even">
<td align="left"><strong>Product</strong></td>
<td align="left">Category.Monoid</td>
<td align="left"><code>*</code></td>
<td align="left">An instance of <code>Monoid</code>, with <code>*</code> defined as append and <code>1</code> as neutral element.</td>
</tr>
<tr class="odd">
<td align="left"><strong>Sum</strong></td>
<td align="left">Category.Monoid</td>
<td align="left"><code>*</code></td>
<td align="left">An instance of <code>Monoid</code>, with <code>+</code> defined as append and <code>0</code> as neutral element.</td>
</tr>
<tr class="even">
<td align="left"><strong>Ord</strong></td>
<td align="left">Category.Ord</td>
<td align="left"><code>*</code></td>
<td align="left">The category which defines <em>lower then</em> and <em>higher then</em>.</td>
</tr>
<tr class="odd">
<td align="left"><strong>Collection</strong> <code>a</code></td>
<td align="left">Collection.Collection</td>
<td align="left"><code>(* ~&gt; *)</code></td>
<td align="left">A <code>Collection</code> is a data structure which contains zero or more elements.</td>
</tr>
<tr class="even">
<td align="left"><strong>Dict</strong> <code>k:Eq</code> <code>v</code></td>
<td align="left">Collection.Dict</td>
<td align="left"><code>(* ~&gt; (* ~&gt; *))</code></td>
<td align="left">A <code>Collection</code> which maps a key onto a value.</td>
</tr>
<tr class="odd">
<td align="left"><strong>List</strong> <code>a</code></td>
<td align="left">Collection.List</td>
<td align="left"><code>(* ~&gt; *)</code></td>
<td align="left">A <code>Collection</code> which preserves order and allows duplicate elements.</td>
</tr>
<tr class="even">
<td align="left"><strong>Maybe</strong> <code>a</code></td>
<td align="left">Collection.Maybe</td>
<td align="left"><code>(* ~&gt; *)</code></td>
<td align="left">A collection which contains at most one value.</td>
</tr>
<tr class="odd">
<td align="left"><strong>More</strong> <code>a</code></td>
<td align="left">Collection.More</td>
<td align="left"><code>(* ~&gt; *)</code></td>
<td align="left">A <code>Collection</code> which contains at least one element.</td>
</tr>
<tr class="even">
<td align="left"><strong>Set</strong> <code>a:Eq</code></td>
<td align="left">Collection.Set</td>
<td align="left"><code>(* ~&gt; *)</code></td>
<td align="left">A <code>Collection</code> without order and duplicates.</td>
</tr>
<tr class="odd">
<td align="left"><strong>Bool</strong></td>
<td align="left">Data.Bool</td>
<td align="left"><code>*</code></td>
<td align="left">The <code>Bool</code> datatype represents truth values of logic.</td>
</tr>
<tr class="even">
<td align="left"><strong>Int</strong></td>
<td align="left">Num.Nat</td>
<td align="left"><code>*</code></td>
<td align="left">An <em>integer</em></td>
</tr>
<tr class="odd">
<td align="left"><strong>Int'</strong></td>
<td align="left">Num.Nat</td>
<td align="left"><code>*</code></td>
<td align="left">An <em>integer</em> which is not zero</td>
</tr>
<tr class="even">
<td align="left"><strong>IntInf</strong></td>
<td align="left">Num.Nat</td>
<td align="left"><code>*</code></td>
<td align="left">An <em>integer</em> or positive or negative <em>Infinity</em> (<code>Inf</code>).</td>
</tr>
<tr class="odd">
<td align="left"><strong>IntInf'</strong></td>
<td align="left">Num.Nat</td>
<td align="left"><code>*</code></td>
<td align="left">An <em>integer</em> which is not zero, or positive or negative <em>Infinity</em> (<code>Inf</code>).</td>
</tr>
<tr class="even">
<td align="left"><strong>Nat</strong></td>
<td align="left">Num.Nat</td>
<td align="left"><code>*</code></td>
<td align="left">A natural number</td>
</tr>
<tr class="odd">
<td align="left"><strong>Nat'</strong></td>
<td align="left">Num.Nat</td>
<td align="left"><code>*</code></td>
<td align="left">A natural number, which is not zero.</td>
</tr>
<tr class="even">
<td align="left"><strong>NatInf</strong></td>
<td align="left">Num.Nat</td>
<td align="left"><code>*</code></td>
<td align="left">A natural number or <em>infinity</em> (<code>Inf</code>).</td>
</tr>
<tr class="odd">
<td align="left"><strong>NatInf'</strong></td>
<td align="left">Num.Nat</td>
<td align="left"><code>*</code></td>
<td align="left">A natural number (which is not zero) or <em>infinity</em> (<code>Inf</code>).</td>
</tr>
<tr class="even">
<td align="left"><strong>Flip</strong> <code>x</code> <code>b</code> <code>a</code></td>
<td align="left">Type.Function</td>
<td align="left"><code>(* ~&gt; (* ~&gt; (* ~&gt; *)))</code></td>
<td align="left">The 'Flip' type takes a type function (<code>* -&gt; * -&gt; *</code>) and flips it arguments. E.g. Flip Dict v k = Dict k v</td>
</tr>
</tbody>
</table>
<h2 id="supertypes">Supertypes</h2>
<table>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Is subtype of</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Any</td>
<td align="left">Any</td>
</tr>
<tr class="even">
<td align="left">Eq</td>
<td align="left">Any</td>
</tr>
<tr class="odd">
<td align="left">Associative<code>a</code></td>
<td align="left">(a -&gt; a -&gt; a)</td>
</tr>
<tr class="even">
<td align="left">Commutative<code>a</code> <code>b</code></td>
<td align="left">(a -&gt; a -&gt; b)</td>
</tr>
<tr class="odd">
<td align="left">Mappable<code>a</code></td>
<td align="left">Any</td>
</tr>
<tr class="even">
<td align="left">Monoid</td>
<td align="left">Any</td>
</tr>
<tr class="odd">
<td align="left">Product</td>
<td align="left">Monoid</td>
</tr>
<tr class="even">
<td align="left">Sum</td>
<td align="left">Monoid</td>
</tr>
<tr class="odd">
<td align="left">Ord</td>
<td align="left">Any</td>
</tr>
<tr class="even">
<td align="left">Collection</td>
<td align="left">Mappable</td>
</tr>
<tr class="odd">
<td align="left">Collection<code>a</code></td>
<td align="left">Monoid</td>
</tr>
<tr class="even">
<td align="left">Dict<code>k</code> <code>v</code></td>
<td align="left">Mappable, Monoid</td>
</tr>
<tr class="odd">
<td align="left">Dict<code>k:Eq</code> <code>v</code></td>
<td align="left">(Set k)</td>
</tr>
<tr class="even">
<td align="left">List</td>
<td align="left">Mappable</td>
</tr>
<tr class="odd">
<td align="left">List<code>a</code></td>
<td align="left">Monoid, (Collection a)</td>
</tr>
<tr class="even">
<td align="left">More</td>
<td align="left">Collection</td>
</tr>
<tr class="odd">
<td align="left">More<code>a</code></td>
<td align="left">Any</td>
</tr>
<tr class="even">
<td align="left">Set<code>a:Eq</code></td>
<td align="left">(Collection a)</td>
</tr>
<tr class="odd">
<td align="left">Int</td>
<td align="left">IntInf</td>
</tr>
<tr class="even">
<td align="left">Int'</td>
<td align="left">Int, IntInf'</td>
</tr>
<tr class="odd">
<td align="left">IntInf</td>
<td align="left">BIInt</td>
</tr>
<tr class="even">
<td align="left">IntInf'</td>
<td align="left">IntInf</td>
</tr>
<tr class="odd">
<td align="left">Nat</td>
<td align="left">NatInf</td>
</tr>
<tr class="even">
<td align="left">Nat'</td>
<td align="left">Nat, NatInf'</td>
</tr>
<tr class="odd">
<td align="left">NatInf</td>
<td align="left">IntInf</td>
</tr>
<tr class="even">
<td align="left">NatInf'</td>
<td align="left">NatInf</td>
</tr>
<tr class="odd">
<td align="left">Flip<code>x</code> <code>b</code> <code>a</code></td>
<td align="left">(x a b)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>This page was automatically generated.</p>
<p>Do not edit it, as regeneration will overwrite your changes.</p>
<p>Back to <a href="Index.html">index</a></p>
</blockquote></article>