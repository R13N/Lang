Annotations

author		"Pieter Vander Vennet"
date		[2014, 10, 18, 23, 24, 42]
desc		"The syntaxis of annotations in Languate. These are really loose."

import Prelude
import Expressions


_$left		::= "Left" | "left"
_$right		::= "Right" | "right"
_$prefix	::= "Prefix" | "prefix"
_$postfix	::= "PostFix" | "postfix"
_modifier	::= left | right | prefix | postfix
_comparator	::= "<" | "=" | ">"
_parOp		::= "\(" $op "\)"
_opComparation	::= parOp comparator parOp
precedenceAnnot	::= "@" "precedence" ":" parOp "is" modifier ","  opComparation ("," opComparation)*

_normalAnnotation	::= "@" ident ":" "!\n{2,}"

annotation		::= precedenceAnnot | normalAnnotation


{-

Operator: precedence and left/right syntax
==========================================

When an operator is defined, you have the possibility to set it's precedence.

e.g.

	@ precedence : Left, (-) = (+), (+) < (*)
	(+)	: ...
	...

This means that ''(+)'' is left associative: ''1 + 2 + 3 = (1 + 2) + 3'' and is executed after (*), thus ''1 + 2 * 3 == 1 + (2*3)''.

Prefix/Postfix
--------------

Can only be used if the function takes one argument.

More-then-three-argument operators
----------------------------------

Not implemented, these should be rare.

Invalid precedence declarations
-------------------------------

- Precedence annotation can only exist when the declaration of the operator is in the same module.
- Only one precedence operator may be defined for each operator, even is it has multiple types.
	When a operator, say ''<=>'', is already imported and redifined with another signature, no precedence annotation may be added.
- Precedence annotations should be consistent.
	''@ precedence : Left, (+) < (*)'' and ''@precedence : Left, (*) < (+)' will generate an error.

The general Annotation System
=============================

The annotation-system, inspired by Java-annotations, is a meta-data system.

However, this system should be used with care. We don't want an explosion in annotations as we have seen in Java, and they should be highly automated.

This is why annotations should only be used for meta-data calculations. It's main use should be to enhance the docs.

To identify the annotation uniquely, an identifier is used. This is to disambiguate different annotations.

class Annotation annot; Annotation in Show:
	identifier	: String
	show	: annot -> String	-- representation in the source file
	parse	: String -> annotation	-- undo show
	docRepr	: annot -> String	-- a doctype representation, should be Markdown
	annotationOf	: Signature -> Context annot -> annot	-- Should always mark a function (but it might be more visits needed)


The annotationOf is called recursively on each function. It is intended that, this way, annotations can 'trickle up', as partial, indicating that something can crash:

	@partial:error
	error	: String -> a
	...

	normalFunction	: ...
		...

	otherNormalFunction : ...
	...	= normalFunction ...

	crashingFunction : ...
	...	= if (...) (normalFunction ...) (error "msg")

This means that ''annotationOf'' normalFunction can see that normalFunction only uses complete functions. It markes it thus with 'partial:no-error'. For crashingFunction, it sees that one of the functions is marked with 'partial:error', and marks the function with 'partial:error' too. This can be noted in the docs. This way one can see, in the autogenerated docs which functions might cause a crash, and which are completely safe.

TODO think about recursion
TODO think about incosistent state (programmer adds conflicting annotations)

In the same way, one can implement ''primitive-recursive'', guaranteeing code which ends; and one can even implement time analysis tools, permission tools, ...

Annotations should **never ever** change behaviour or semantics of functions. This is why there is **strictly no way** to get the annotation of a function.

There is one (hardcoded) exception to this rule: infix operator priorities. However, these are not really annotations (despite syntactically and conceptually looking like annotations)


-}
